# db.py (PostgreSQL / asyncpg)
import os
import time
import calendar
from datetime import datetime, timezone, timedelta
from typing import List, Dict, Optional, Tuple

import asyncpg

DATABASE_URL = os.getenv("DATABASE_URL", "").strip()

_pool: Optional[asyncpg.Pool] = None


async def get_pool() -> asyncpg.Pool:
	global _pool
	if _pool is None:
		if not DATABASE_URL:
			raise RuntimeError("DATABASE_URL env var is not set. Add it in Railway Variables.")
		_pool = await asyncpg.create_pool(DATABASE_URL, min_size=1, max_size=10)
	return _pool


# ===================== INIT + MIGRATIONS =====================

async def _column_exists(conn: asyncpg.Connection, table: str, column: str) -> bool:
	q = """
	SELECT 1
	FROM information_schema.columns
	WHERE table_schema='public' AND table_name=$1 AND column_name=$2
	LIMIT 1
	"""
	return await conn.fetchval(q, table, column) is not None


async def _table_exists(conn: asyncpg.Connection, table: str) -> bool:
	q = """
	SELECT 1
	FROM information_schema.tables
	WHERE table_schema='public' AND table_name=$1
	LIMIT 1
	"""
	return await conn.fetchval(q, table) is not None


def _norm_mode(mode: str) -> str:
	m = (mode or "").strip().lower()
	if m not in ("off", "manual", "auto"):
		return "off"
	return m


def _norm_action_type(t: str) -> str:
	# на будущее можно добавить другие types (send_message, etc)
	tt = (t or "").strip().lower()
	if tt not in ("start_flow",):
		return "start_flow"
	return tt


def _unit_to_seconds(unit: str) -> int:
	u = (unit or "").strip().lower()
	if u == "seconds":
		return 1
	if u == "minutes":
		return 60
	if u == "hours":
		return 3600
	return 86400  # days default


def seconds_to_value_unit(total_seconds: int, preferred_unit: str = "minutes") -> Tuple[int, str]:
	s = int(total_seconds or 0)
	p = (preferred_unit or "minutes").strip().lower()
	if p not in ("seconds", "minutes", "hours", "days"):
		p = "minutes"
	
	if s <= 0:
		return 0, p
	
	if s % 86400 == 0:
		return s // 86400, "days"
	if s % 3600 == 0:
		return s // 3600, "hours"
	if s % 60 == 0:
		return s // 60, "minutes"
	
	# иначе — показываем как секунды (честно)
	return s, "seconds"


def value_unit_to_seconds(value: int, unit: str) -> int:
	v = int(value or 0)
	if v < 0:
		v = 0
	return v * _unit_to_seconds(unit)


async def init_db():
	pool = await get_pool()
	async with pool.acquire() as conn:
		# --- USERS ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS users (
			user_id BIGINT PRIMARY KEY,
			state TEXT DEFAULT '',
			flow_status TEXT DEFAULT '',
			last_start_at TEXT DEFAULT '',
			updated_at TEXT DEFAULT ''
		);
		""")

		# --- FLOWS ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS flows (
			name TEXT PRIMARY KEY,
			sort_order INTEGER NOT NULL DEFAULT 0
		);
		""")

		# --- CONTENT BLOCKS ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS content_blocks (
			id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			flow TEXT NOT NULL,
			position INTEGER NOT NULL,
			type TEXT NOT NULL,
			title TEXT DEFAULT '',
			text TEXT DEFAULT '',
			circle_path TEXT DEFAULT '',
			video_url TEXT DEFAULT '',
			buttons_json TEXT DEFAULT '',
			delay_seconds DOUBLE PRECISION DEFAULT 1.0,
			is_active INTEGER DEFAULT 1,

			-- attachments
			file_path TEXT DEFAULT '',
			file_kind TEXT DEFAULT '',
			file_name TEXT DEFAULT '',

			-- GATE
			gate_next_flow TEXT DEFAULT '',
			gate_button_text TEXT DEFAULT '',
			gate_prompt_text TEXT DEFAULT '',     -- ✅ текст над кнопкой (редактируется в CRM)
			gate_reminder_seconds BIGINT NOT NULL DEFAULT 0,
			gate_reminder_text TEXT DEFAULT ''
		);
		""")

		# --- JOBS ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS jobs (
			id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			user_id BIGINT NOT NULL,
			flow TEXT NOT NULL,
			run_at_ts BIGINT NOT NULL,
			is_done INTEGER DEFAULT 0
		);
		""")

		await conn.execute("""
		CREATE UNIQUE INDEX IF NOT EXISTS ux_jobs_user_flow
		ON jobs(user_id, flow);
		""")

		# --- BOT USERS ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS bot_users (
			user_id BIGINT PRIMARY KEY,
			username TEXT DEFAULT '',
			first_seen_ts BIGINT NOT NULL,
			last_seen_ts BIGINT NOT NULL,
			starts_count BIGINT NOT NULL DEFAULT 0,
			messages_count BIGINT NOT NULL DEFAULT 0
		);
		""")

		# --- FLOW TRIGGERS (auto after /start) ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS flow_triggers (
			flow TEXT PRIMARY KEY,
			trigger TEXT NOT NULL DEFAULT 'after_start',
			offset_seconds BIGINT NOT NULL DEFAULT 0,
			is_active INTEGER NOT NULL DEFAULT 1
		);
		""")

		# --- USER GATES ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS user_gates (
			user_id BIGINT NOT NULL,
			block_id INTEGER NOT NULL,
			pressed_at INTEGER NOT NULL,
			PRIMARY KEY (user_id, block_id)
		);
		""")

		# ✅ FLOW MODES (off/manual/auto) — управляется из CRM
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS flow_modes (
			flow TEXT PRIMARY KEY,
			mode TEXT NOT NULL DEFAULT 'off'
		);
		""")

		# ✅ FLOW ACTIONS: после какого flow запускать другой (или другое действие)
		# сейчас делаем самый нужный кейс: after_flow -> start_flow(target_flow) через delay
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS flow_actions (
			id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			after_flow TEXT NOT NULL,
			action_type TEXT NOT NULL DEFAULT 'start_flow',
			target_flow TEXT NOT NULL,
			delay_seconds BIGINT NOT NULL DEFAULT 0,
			is_active INTEGER NOT NULL DEFAULT 1
		);
		""")

		await conn.execute("""
		CREATE UNIQUE INDEX IF NOT EXISTS ux_flow_actions_unique
		ON flow_actions(after_flow, action_type, target_flow);
		""")

		# ✅ BROADCASTS (recurring campaigns)
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS broadcasts (
			id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			title TEXT NOT NULL DEFAULT '',
			flow TEXT NOT NULL,
			target_user_id BIGINT,                 -- NULL = all users
			schedule_type TEXT NOT NULL DEFAULT 'monthly',  -- monthly | interval_days
			interval_days BIGINT NOT NULL DEFAULT 30,       -- for interval_days
			days_of_month TEXT NOT NULL DEFAULT '1',        -- for monthly: "1" or "1,15"
			at_hour INTEGER NOT NULL DEFAULT 12,            -- 0..23
			at_minute INTEGER NOT NULL DEFAULT 0,           -- 0..59
			next_run_ts BIGINT NOT NULL DEFAULT 0,
			last_run_ts BIGINT NOT NULL DEFAULT 0,
			is_active INTEGER NOT NULL DEFAULT 1,
			created_ts BIGINT NOT NULL DEFAULT 0
		);
		""")

		# ---------------- MIGRATIONS ----------------

		if not await _column_exists(conn, "flows", "sort_order"):
			await conn.execute("ALTER TABLE flows ADD COLUMN sort_order INTEGER NOT NULL DEFAULT 0;")

		for col, ddl in [
			("delay_seconds", "ALTER TABLE content_blocks ADD COLUMN delay_seconds DOUBLE PRECISION DEFAULT 1.0;"),
			("title", "ALTER TABLE content_blocks ADD COLUMN title TEXT DEFAULT '';"),
			("file_path", "ALTER TABLE content_blocks ADD COLUMN file_path TEXT DEFAULT '';"),
			("file_kind", "ALTER TABLE content_blocks ADD COLUMN file_kind TEXT DEFAULT '';"),
			("file_name", "ALTER TABLE content_blocks ADD COLUMN file_name TEXT DEFAULT '';"),

			("gate_next_flow", "ALTER TABLE content_blocks ADD COLUMN gate_next_flow TEXT DEFAULT '';"),
			("gate_button_text", "ALTER TABLE content_blocks ADD COLUMN gate_button_text TEXT DEFAULT '';"),
			("gate_prompt_text", "ALTER TABLE content_blocks ADD COLUMN gate_prompt_text TEXT DEFAULT '';"),
			("gate_reminder_seconds", "ALTER TABLE content_blocks ADD COLUMN gate_reminder_seconds BIGINT NOT NULL DEFAULT 0;"),
			("gate_reminder_text", "ALTER TABLE content_blocks ADD COLUMN gate_reminder_text TEXT DEFAULT '';"),
		]:
			if not await _column_exists(conn, "content_blocks", col):
				await conn.execute(ddl)

		if not await _table_exists(conn, "user_gates"):
			await conn.execute("""
			CREATE TABLE IF NOT EXISTS user_gates (
				user_id BIGINT NOT NULL,
				block_id INTEGER NOT NULL,
				pressed_at INTEGER NOT NULL,
				PRIMARY KEY (user_id, block_id)
			);
			""")

		if not await _table_exists(conn, "flow_modes"):
			await conn.execute("""
			CREATE TABLE IF NOT EXISTS flow_modes (
				flow TEXT PRIMARY KEY,
				mode TEXT NOT NULL DEFAULT 'off'
			);
			""")

		if not await _table_exists(conn, "flow_actions"):
			await conn.execute("""
			CREATE TABLE IF NOT EXISTS flow_actions (
				id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
				after_flow TEXT NOT NULL,
				action_type TEXT NOT NULL DEFAULT 'start_flow',
				target_flow TEXT NOT NULL,
				delay_seconds BIGINT NOT NULL DEFAULT 0,
				is_active INTEGER NOT NULL DEFAULT 1
			);
			""")

		# ✅ ensure broadcasts exists (older DB)
		if not await _table_exists(conn, "broadcasts"):
			await conn.execute("""
			CREATE TABLE IF NOT EXISTS broadcasts (
				id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
				title TEXT NOT NULL DEFAULT '',
				flow TEXT NOT NULL,
				target_user_id BIGINT,
				schedule_type TEXT NOT NULL DEFAULT 'monthly',
				interval_days BIGINT NOT NULL DEFAULT 30,
				days_of_month TEXT NOT NULL DEFAULT '1',
				at_hour INTEGER NOT NULL DEFAULT 12,
				at_minute INTEGER NOT NULL DEFAULT 0,
				next_run_ts BIGINT NOT NULL DEFAULT 0,
				last_run_ts BIGINT NOT NULL DEFAULT 0,
				is_active INTEGER NOT NULL DEFAULT 1,
				created_ts BIGINT NOT NULL DEFAULT 0
			);
			""")

		# restore flows if empty
		cnt = await conn.fetchval("SELECT COUNT(*) FROM flows;")
		if int(cnt or 0) == 0:
			rows = await conn.fetch("SELECT DISTINCT flow FROM content_blocks ORDER BY flow;")
			order = 1
			for r in rows:
				flow = r["flow"]
				await conn.execute(
					"INSERT INTO flows(name, sort_order) VALUES ($1, $2) ON CONFLICT (name) DO NOTHING;",
					flow, order
				)
				order += 1

		# ✅ ensure flow_modes exists for every flow (default off)
		flow_rows = await conn.fetch("SELECT name FROM flows;")
		for r in flow_rows:
			f = (r["name"] or "").strip()
			if not f:
				continue
			await conn.execute("""
			INSERT INTO flow_modes(flow, mode)
			VALUES ($1, 'off')
			ON CONFLICT (flow) DO NOTHING;
			""", f)


# ===================== BROADCASTS (recurring) =====================

def _now_ts() -> int:
	return int(time.time())


def _parse_days_csv(s: str) -> List[int]:
	out: List[int] = []
	for part in (s or "").split(","):
		part = part.strip()
		if not part:
			continue
		try:
			d = int(part)
		except Exception:
			continue
		if 1 <= d <= 31:
			out.append(d)
	out = sorted(set(out))
	return out if out else [1]


def _compute_next_monthly(days_csv: str, at_hour: int, at_minute: int, from_ts: Optional[int] = None) -> int:
	"""
	Следующее срабатывание по дням месяца (например '1' или '1,15') в UTC.
	"""
	from_ts = int(from_ts or _now_ts())
	dt = datetime.fromtimestamp(from_ts, tz=timezone.utc)

	days = _parse_days_csv(days_csv)
	at_hour = max(0, min(23, int(at_hour or 0)))
	at_minute = max(0, min(59, int(at_minute or 0)))

	# текущий месяц, затем следующий
	for add_month in (0, 1, 2):
		y = dt.year
		m = dt.month + add_month
		while m > 12:
			y += 1
			m -= 12

		last_day = calendar.monthrange(y, m)[1]
		for d in days:
			dd = min(d, last_day)
			candidate = datetime(y, m, dd, at_hour, at_minute, 0, tzinfo=timezone.utc)
			if int(candidate.timestamp()) > from_ts:
				return int(candidate.timestamp())

	# fallback
	return from_ts + 30 * 86400


def _compute_next_interval_days(interval_days: int, at_hour: int, at_minute: int, from_ts: Optional[int] = None) -> int:
	from_ts = int(from_ts or _now_ts())
	interval_days = max(1, int(interval_days or 1))
	at_hour = max(0, min(23, int(at_hour or 0)))
	at_minute = max(0, min(59, int(at_minute or 0)))

	next_dt = datetime.fromtimestamp(from_ts, tz=timezone.utc) + timedelta(days=interval_days)
	next_run = datetime(next_dt.year, next_dt.month, next_dt.day, at_hour, at_minute, 0, tzinfo=timezone.utc)
	return int(next_run.timestamp())


async def get_all_user_ids(limit: int = 200000) -> List[int]:
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("SELECT user_id FROM bot_users ORDER BY user_id ASC LIMIT $1;", int(limit))
	return [int(r["user_id"]) for r in rows]


async def list_broadcasts() -> List[Dict]:
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("""
			SELECT id, title, flow, target_user_id, schedule_type, interval_days, days_of_month,
				   at_hour, at_minute, next_run_ts, last_run_ts, is_active, created_ts
			FROM broadcasts
			ORDER BY id DESC;
		""")
	return [
		{
			"id": int(r["id"]),
			"title": r["title"] or "",
			"flow": (r["flow"] or "").strip(),
			"target_user_id": (int(r["target_user_id"]) if r["target_user_id"] is not None else None),
			"schedule_type": (r["schedule_type"] or "monthly").strip(),
			"interval_days": int(r["interval_days"] or 30),
			"days_of_month": (r["days_of_month"] or "1").strip(),
			"at_hour": int(r["at_hour"] or 12),
			"at_minute": int(r["at_minute"] or 0),
			"next_run_ts": int(r["next_run_ts"] or 0),
			"last_run_ts": int(r["last_run_ts"] or 0),
			"is_active": int(r["is_active"] or 0),
			"created_ts": int(r["created_ts"] or 0),
		}
		for r in rows
	]


async def create_broadcast(
	title: str,
	flow: str,
	target_user_id: Optional[int],
	schedule_type: str,
	interval_days: int,
	days_of_month: str,
	at_hour: int,
	at_minute: int,
	is_active: int = 1,
) -> None:
	title = (title or "").strip()
	flow = (flow or "").strip()
	if not flow:
		return

	st = (schedule_type or "monthly").strip().lower()
	if st not in ("monthly", "interval_days"):
		st = "monthly"

	target_uid: Optional[int] = None
	try:
		if target_user_id is not None:
			target_uid = int(target_user_id)
	except Exception:
		target_uid = None

	now = _now_ts()

	if st == "monthly":
		next_run = _compute_next_monthly(days_of_month, at_hour, at_minute, from_ts=now)
	else:
		next_run = _compute_next_interval_days(interval_days, at_hour, at_minute, from_ts=now)

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
			INSERT INTO broadcasts
			(title, flow, target_user_id, schedule_type, interval_days, days_of_month, at_hour, at_minute,
			 next_run_ts, last_run_ts, is_active, created_ts)
			VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,0,$10,$11);
		""",
			title,
			flow,
			target_uid,
			st,
			int(interval_days or 30),
			(days_of_month or "1").strip(),
			int(at_hour or 12),
			int(at_minute or 0),
			int(next_run),
			1 if int(is_active) else 0,
			now,
		)


async def delete_broadcast(broadcast_id: int) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("DELETE FROM broadcasts WHERE id=$1;", int(broadcast_id))


async def set_broadcast_active(broadcast_id: int, is_active: int) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute(
			"UPDATE broadcasts SET is_active=$2 WHERE id=$1;",
			int(broadcast_id),
			1 if int(is_active) else 0,
		)


async def fetch_due_broadcasts(limit: int = 20) -> List[Dict]:
	now = _now_ts()
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("""
			SELECT id, title, flow, target_user_id, schedule_type, interval_days, days_of_month,
				   at_hour, at_minute, next_run_ts
			FROM broadcasts
			WHERE is_active=1 AND next_run_ts > 0 AND next_run_ts <= $1
			ORDER BY next_run_ts ASC
			LIMIT $2;
		""", now, int(limit))

	return [
		{
			"id": int(r["id"]),
			"title": r["title"] or "",
			"flow": (r["flow"] or "").strip(),
			"target_user_id": (int(r["target_user_id"]) if r["target_user_id"] is not None else None),
			"schedule_type": (r["schedule_type"] or "monthly").strip(),
			"interval_days": int(r["interval_days"] or 30),
			"days_of_month": (r["days_of_month"] or "1").strip(),
			"at_hour": int(r["at_hour"] or 12),
			"at_minute": int(r["at_minute"] or 0),
			"next_run_ts": int(r["next_run_ts"] or 0),
		}
		for r in rows
	]


async def bump_broadcast_next_run(broadcast_id: int) -> None:
	"""
	После обработки кампании пересчитываем next_run_ts.
	"""
	pool = await get_pool()
	async with pool.acquire() as conn:
		r = await conn.fetchrow("""
			SELECT schedule_type, interval_days, days_of_month, at_hour, at_minute
			FROM broadcasts
			WHERE id=$1;
		""", int(broadcast_id))
		if not r:
			return

		now = _now_ts()
		st = (r["schedule_type"] or "monthly").strip().lower()
		interval_days = int(r["interval_days"] or 30)
		days_of_month = (r["days_of_month"] or "1").strip()
		at_hour = int(r["at_hour"] or 12)
		at_minute = int(r["at_minute"] or 0)

		if st == "monthly":
			next_run = _compute_next_monthly(days_of_month, at_hour, at_minute, from_ts=now)
		else:
			next_run = _compute_next_interval_days(interval_days, at_hour, at_minute, from_ts=now)

		await conn.execute("""
			UPDATE broadcasts
			SET last_run_ts=$2, next_run_ts=$3
			WHERE id=$1;
		""", int(broadcast_id), int(now), int(next_run))


# ===================== FLOW MODES =====================

async def get_flow_modes() -> Dict[str, str]:
	"""
	Возвращает dict: { flow: mode } где mode in ('off','manual','auto')
	"""
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("SELECT flow, mode FROM flow_modes ORDER BY flow ASC;")
	out: Dict[str, str] = {}
	for r in rows:
		f = (r["flow"] or "").strip()
		m = _norm_mode(r["mode"] or "off")
		if f:
			out[f] = m
	return out


async def set_flow_mode(flow: str, mode: str) -> None:
	flow = (flow or "").strip()
	if not flow:
		return
	mode = _norm_mode(mode)

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		INSERT INTO flow_modes(flow, mode)
		VALUES ($1, $2)
		ON CONFLICT (flow) DO UPDATE SET
			mode=EXCLUDED.mode;
		""", flow, mode)


# ===================== FLOW ACTIONS =====================

async def get_flow_actions(after_flow: Optional[str] = None) -> List[Dict]:
	"""
	Сценарии "после flow".
	Пример: after_flow='day3' -> start_flow('final') через 10 минут.
	"""
	pool = await get_pool()
	async with pool.acquire() as conn:
		if after_flow is not None:
			after_flow = (after_flow or "").strip()
			rows = await conn.fetch("""
			SELECT id, after_flow, action_type, target_flow, delay_seconds, is_active
			FROM flow_actions
			WHERE after_flow=$1
			ORDER BY id ASC;
			""", after_flow)
		else:
			rows = await conn.fetch("""
			SELECT id, after_flow, action_type, target_flow, delay_seconds, is_active
			FROM flow_actions
			ORDER BY after_flow ASC, id ASC;
			""")

	return [
		{
			"id": int(r["id"]),
			"after_flow": (r["after_flow"] or "").strip(),
			"action_type": (r["action_type"] or "start_flow").strip(),
			"target_flow": (r["target_flow"] or "").strip(),
			"delay_seconds": int(r["delay_seconds"] or 0),
			"is_active": int(r["is_active"] or 0),
		}
		for r in rows
	]


async def upsert_flow_action(
	after_flow: str,
	target_flow: str,
	delay_seconds: int = 0,
	is_active: int = 1,
	action_type: str = "start_flow",
) -> None:
	after_flow = (after_flow or "").strip()
	target_flow = (target_flow or "").strip()
	if not after_flow or not target_flow:
		return

	action_type = _norm_action_type(action_type)
	delay_seconds = int(delay_seconds or 0)
	if delay_seconds < 0:
		delay_seconds = 0
	is_active = 1 if int(is_active) else 0

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		INSERT INTO flow_actions(after_flow, action_type, target_flow, delay_seconds, is_active)
		VALUES ($1, $2, $3, $4, $5)
		ON CONFLICT (after_flow, action_type, target_flow) DO UPDATE SET
			delay_seconds=EXCLUDED.delay_seconds,
			is_active=EXCLUDED.is_active;
		""", after_flow, action_type, target_flow, delay_seconds, is_active)


async def delete_flow_action(action_id: int) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("DELETE FROM flow_actions WHERE id=$1;", int(action_id))


async def delete_flow_actions_for_flow(flow: str) -> None:
	"""
	Удобно при delete_flow(): убрать сценарии где flow участвует
	"""
	flow = (flow or "").strip()
	if not flow:
		return
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		DELETE FROM flow_actions
		WHERE after_flow=$1 OR target_flow=$1;
		""", flow)


# ===================== BOT ANALYTICS =====================

async def inc_start(user_id: int, username: Optional[str]):
	now = int(time.time())
	username = (username or "").strip()

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		INSERT INTO bot_users(user_id, username, first_seen_ts, last_seen_ts, starts_count, messages_count)
		VALUES ($1, $2, $3, $4, 1, 0)
		ON CONFLICT (user_id) DO UPDATE SET
			username=EXCLUDED.username,
			last_seen_ts=EXCLUDED.last_seen_ts,
			starts_count=bot_users.starts_count + 1;
		""", int(user_id), username, now, now)


async def inc_message(user_id: int, username: Optional[str]):
	now = int(time.time())
	username = (username or "").strip()

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		INSERT INTO bot_users(user_id, username, first_seen_ts, last_seen_ts, starts_count, messages_count)
		VALUES ($1, $2, $3, $4, 0, 1)
		ON CONFLICT (user_id) DO UPDATE SET
			username=EXCLUDED.username,
			last_seen_ts=EXCLUDED.last_seen_ts,
			messages_count=bot_users.messages_count + 1;
		""", int(user_id), username, now, now)


async def get_stats():
	now = int(time.time())
	hour_ago = now - 3600

	pool = await get_pool()
	async with pool.acquire() as conn:
		total_users = await conn.fetchval("SELECT COUNT(*) FROM bot_users;")
		active_last_hour = await conn.fetchval(
			"SELECT COUNT(*) FROM bot_users WHERE last_seen_ts >= $1;",
			hour_ago
		)
		row = await conn.fetchrow("""
			SELECT COALESCE(SUM(starts_count),0) AS starts,
				   COALESCE(SUM(messages_count),0) AS messages
			FROM bot_users;
		""")

	return {
		"total_users": int(total_users or 0),
		"active_last_hour": int(active_last_hour or 0),
		"total_starts": int(row["starts"] or 0),
		"total_messages": int(row["messages"] or 0),
	}


async def get_users(limit: int = 500):
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("""
		SELECT user_id, username, first_seen_ts, last_seen_ts, starts_count, messages_count
		FROM bot_users
		ORDER BY last_seen_ts DESC
		LIMIT $1;
		""", int(limit))

	return [
		{
			"user_id": int(r["user_id"]),
			"username": r["username"] or "",
			"first_seen_ts": int(r["first_seen_ts"]),
			"last_seen_ts": int(r["last_seen_ts"]),
			"starts_count": int(r["starts_count"]),
			"messages_count": int(r["messages_count"]),
		}
		for r in rows
	]


# ===================== FLOW TRIGGERS =====================

async def get_flow_triggers() -> List[Dict]:
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("""
		SELECT flow, trigger, offset_seconds, is_active
		FROM flow_triggers
		ORDER BY offset_seconds ASC, flow ASC;
		""")

	return [
		{
			"flow": r["flow"],
			"trigger": r["trigger"],
			"offset_seconds": int(r["offset_seconds"] or 0),
			"is_active": int(r["is_active"] or 0),
		}
		for r in rows
	]


async def set_flow_trigger(flow: str, offset_seconds: int, is_active: int = 1, trigger: str = "after_start") -> None:
	flow = (flow or "").strip()
	if not flow:
		return

	offset_seconds = int(offset_seconds)
	is_active = 1 if int(is_active) else 0
	trigger = (trigger or "after_start").strip() or "after_start"

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		INSERT INTO flow_triggers(flow, trigger, offset_seconds, is_active)
		VALUES ($1, $2, $3, $4)
		ON CONFLICT (flow) DO UPDATE SET
			trigger=EXCLUDED.trigger,
			offset_seconds=EXCLUDED.offset_seconds,
			is_active=EXCLUDED.is_active;
		""", flow, trigger, offset_seconds, is_active)


async def delete_flow_trigger(flow: str) -> None:
	flow = (flow or "").strip()
	if not flow:
		return

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("DELETE FROM flow_triggers WHERE flow=$1;", flow)


# ===================== GATES (pressed state) =====================

async def mark_gate_pressed(user_id: int, block_id: int) -> None:
	now = int(time.time())
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		INSERT INTO user_gates(user_id, block_id, pressed_at)
		VALUES ($1, $2, $3)
		ON CONFLICT (user_id, block_id) DO UPDATE SET
			pressed_at=EXCLUDED.pressed_at;
		""", int(user_id), int(block_id), now)


async def is_gate_pressed(user_id: int, block_id: int) -> bool:
	pool = await get_pool()
	async with pool.acquire() as conn:
		v = await conn.fetchval("""
		SELECT 1
		FROM user_gates
		WHERE user_id=$1 AND block_id=$2
		LIMIT 1;
		""", int(user_id), int(block_id))
	return v is not None


async def unpress_gate(user_id: int, block_id: int) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		DELETE FROM user_gates
		WHERE user_id=$1 AND block_id=$2;
		""", int(user_id), int(block_id))


# ===================== JOBS =====================

async def upsert_job(user_id: int, flow: str, run_at_ts: int) -> None:
	flow = (flow or "").strip()
	if not flow:
		return

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		INSERT INTO jobs(user_id, flow, run_at_ts, is_done)
		VALUES ($1, $2, $3, 0)
		ON CONFLICT (user_id, flow) DO UPDATE SET
			run_at_ts=EXCLUDED.run_at_ts,
			is_done=0;
		""", int(user_id), flow, int(run_at_ts))


async def fetch_due_jobs(limit: int = 50) -> List[Dict]:
	now = int(time.time())

	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("""
		SELECT id, user_id, flow, run_at_ts
		FROM jobs
		WHERE is_done=0 AND run_at_ts <= $1
		ORDER BY run_at_ts ASC
		LIMIT $2;
		""", now, int(limit))

	return [
		{
			"id": int(r["id"]),
			"user_id": int(r["user_id"]),
			"flow": r["flow"],
			"run_at_ts": int(r["run_at_ts"]),
		}
		for r in rows
	]


async def mark_job_done(job_id: int) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("UPDATE jobs SET is_done=1 WHERE id=$1;", int(job_id))


async def mark_job_done_by_user_flow(user_id: int, flow: str) -> None:
	"""
	Нужно чтобы “отменить” напоминание по ключу (user_id, flow),
	потому что jobs у нас unique по (user_id, flow).
	"""
	flow = (flow or "").strip()
	if not flow:
		return
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		UPDATE jobs
		SET is_done=1
		WHERE user_id=$1 AND flow=$2;
		""", int(user_id), flow)


# ===================== FLOWS =====================

async def get_flows() -> List[str]:
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("SELECT name FROM flows ORDER BY sort_order ASC;")
	return [r["name"] for r in rows]


async def create_flow(name: str) -> None:
	name = (name or "").strip()
	if not name:
		return

	pool = await get_pool()
	async with pool.acquire() as conn:
		mx = await conn.fetchval("SELECT COALESCE(MAX(sort_order), 0) FROM flows;")
		await conn.execute(
			"INSERT INTO flows(name, sort_order) VALUES ($1, $2) ON CONFLICT (name) DO NOTHING;",
			name, int(mx or 0) + 1
		)

	# ✅ default mode off
	try:
		await set_flow_mode(name, "off")
	except Exception:
		pass


async def delete_flow(name: str) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		async with conn.transaction():
			await conn.execute("DELETE FROM content_blocks WHERE flow=$1;", name)
			await conn.execute("DELETE FROM jobs WHERE flow=$1;", name)
			await conn.execute("DELETE FROM flow_triggers WHERE flow=$1;", name)
			await conn.execute("DELETE FROM flow_modes WHERE flow=$1;", name)
			await conn.execute("DELETE FROM flows WHERE name=$1;", name)
			# ✅ удалить сценарии, где участвует этот flow
			await conn.execute("DELETE FROM flow_actions WHERE after_flow=$1 OR target_flow=$1;", name)


async def move_flow(name: str, direction: str) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("SELECT name, sort_order FROM flows ORDER BY sort_order ASC;")
		idx = next((i for i, r in enumerate(rows) if r["name"] == name), None)
		if idx is None:
			return

		if direction == "up" and idx > 0:
			a = rows[idx]
			b = rows[idx - 1]
		elif direction == "down" and idx < len(rows) - 1:
			a = rows[idx]
			b = rows[idx + 1]
		else:
			return

		async with conn.transaction():
			await conn.execute("UPDATE flows SET sort_order=$1 WHERE name=$2;", int(b["sort_order"]), a["name"])
			await conn.execute("UPDATE flows SET sort_order=$1 WHERE name=$2;", int(a["sort_order"]), b["name"])


# ===================== CONTENT BLOCKS =====================

async def next_position(flow: str) -> int:
	pool = await get_pool()
	async with pool.acquire() as conn:
		mx = await conn.fetchval("SELECT COALESCE(MAX(position), 0) FROM content_blocks WHERE flow=$1;", flow)
		return int(mx or 0) + 1


async def get_blocks(flow: str) -> List[Dict]:
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("""
			SELECT
				id, flow, position, type,
				title, text,
				circle_path, video_url, buttons_json,
				is_active, delay_seconds,
				file_path, file_kind, file_name,
				gate_next_flow, gate_button_text, gate_prompt_text, gate_reminder_seconds, gate_reminder_text
			FROM content_blocks
			WHERE flow=$1
			ORDER BY position ASC;
		""", flow)

	return [
		{
			"id": int(r["id"]),
			"flow": r["flow"],
			"position": int(r["position"]),
			"type": r["type"],
			"title": r["title"] or "",
			"text": r["text"] or "",
			"circle": r["circle_path"] or "",
			"video": r["video_url"] or "",
			"buttons": r["buttons_json"] or "",
			"is_active": int(r["is_active"] or 0),
			"delay": float(r["delay_seconds"] or 1.0),

			"file_path": r["file_path"] or "",
			"file_kind": r["file_kind"] or "",
			"file_name": r["file_name"] or "",

			"gate_next_flow": r.get("gate_next_flow") or "",
			"gate_button_text": r.get("gate_button_text") or "",
			"gate_prompt_text": r.get("gate_prompt_text") or "",
			"gate_reminder_seconds": int(r.get("gate_reminder_seconds") or 0),
			"gate_reminder_text": r.get("gate_reminder_text") or "",
		}
		for r in rows
	]


async def get_block(block_id: int) -> Optional[Dict]:
	pool = await get_pool()
	async with pool.acquire() as conn:
		r = await conn.fetchrow("""
			SELECT
				id, flow, position, type,
				title, text,
				circle_path, video_url, buttons_json,
				is_active, delay_seconds,
				file_path, file_kind, file_name,
				gate_next_flow, gate_button_text, gate_prompt_text, gate_reminder_seconds, gate_reminder_text
			FROM content_blocks
			WHERE id=$1;
		""", int(block_id))

	if not r:
		return None

	return {
		"id": int(r["id"]),
		"flow": r["flow"],
		"position": int(r["position"]),
		"type": r["type"],
		"title": r["title"] or "",
		"text": r["text"] or "",
		"circle": r["circle_path"] or "",
		"video": r["video_url"] or "",
		"buttons": r["buttons_json"] or "",
		"is_active": int(r["is_active"] or 0),
		"delay": float(r["delay_seconds"] or 1.0),

		"file_path": r["file_path"] or "",
		"file_kind": r["file_kind"] or "",
		"file_name": r["file_name"] or "",

		"gate_next_flow": r.get("gate_next_flow") or "",
		"gate_button_text": r.get("gate_button_text") or "",
		"gate_prompt_text": r.get("gate_prompt_text") or "",
		"gate_reminder_seconds": int(r.get("gate_reminder_seconds") or 0),
		"gate_reminder_text": r.get("gate_reminder_text") or "",
	}


async def create_block(data: Dict) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
			INSERT INTO content_blocks
			(flow, position, type, title, text, circle_path, video_url, buttons_json,
			 is_active, delay_seconds, file_path, file_kind, file_name,
			 gate_next_flow, gate_button_text, gate_prompt_text, gate_reminder_seconds, gate_reminder_text)
			VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18);
		""",
			data["flow"], int(data["position"]), data["type"],
			data.get("title", ""), data.get("text", ""),
			data.get("circle", ""), data.get("video", ""),
			data.get("buttons", ""), int(data.get("is_active", 1)),
			float(data.get("delay", 1.0)),
			data.get("file_path", ""),
			data.get("file_kind", ""),
			data.get("file_name", ""),
			data.get("gate_next_flow", ""),
			data.get("gate_button_text", ""),
			data.get("gate_prompt_text", ""),
			int(data.get("gate_reminder_seconds", 0) or 0),
			data.get("gate_reminder_text", ""),
		)


async def update_block(block_id: int, data: Dict) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
			UPDATE content_blocks
			SET flow=$1, position=$2, type=$3,
				title=$4, text=$5, circle_path=$6, video_url=$7, buttons_json=$8,
				is_active=$9, delay_seconds=$10,
				file_path=$11, file_kind=$12, file_name=$13,
				gate_next_flow=$14, gate_button_text=$15, gate_prompt_text=$16, gate_reminder_seconds=$17, gate_reminder_text=$18
			WHERE id=$19;
		""",
			data["flow"], int(data["position"]), data["type"],
			data.get("title", ""), data.get("text", ""),
			data.get("circle", ""), data.get("video", ""),
			data.get("buttons", ""), int(data.get("is_active", 1)),
			float(data.get("delay", 1.0)),
			data.get("file_path", ""),
			data.get("file_kind", ""),
			data.get("file_name", ""),
			data.get("gate_next_flow", ""),
			data.get("gate_button_text", ""),
			data.get("gate_prompt_text", ""),
			int(data.get("gate_reminder_seconds", 0) or 0),
			data.get("gate_reminder_text", ""),
			int(block_id),
		)


async def delete_block(block_id: int) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("DELETE FROM content_blocks WHERE id=$1;", int(block_id))


async def swap_positions(id_a: int, id_b: int) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		async with conn.transaction():
			a_pos = await conn.fetchval("SELECT position FROM content_blocks WHERE id=$1;", int(id_a))
			b_pos = await conn.fetchval("SELECT position FROM content_blocks WHERE id=$1;", int(id_b))
			if a_pos is None or b_pos is None:
				return
			await conn.execute("UPDATE content_blocks SET position=$1 WHERE id=$2;", int(b_pos), int(id_a))
			await conn.execute("UPDATE content_blocks SET position=$1 WHERE id=$2;", int(a_pos), int(id_b))