# db.py (PostgreSQL / asyncpg)
import os
import time
from typing import List, Dict, Optional

import asyncpg

DATABASE_URL = os.getenv("DATABASE_URL", "").strip()

# pool is shared inside one process (CRM process and BOT process each will have its own pool)
_pool: Optional[asyncpg.Pool] = None


async def get_pool() -> asyncpg.Pool:
	global _pool
	if _pool is None:
		if not DATABASE_URL:
			raise RuntimeError("DATABASE_URL env var is not set. Add it in Railway Variables.")
		# Railway often uses ssl; asyncpg handles it via URL params.
		_pool = await asyncpg.create_pool(DATABASE_URL, min_size=1, max_size=10)
	return _pool


# ===================== INIT + MIGRATIONS =====================

async def _column_exists(conn: asyncpg.Connection, table: str, column: str) -> bool:
	q = """
	SELECT 1
	FROM information_schema.columns
	WHERE table_schema='public' AND table_name=$1 AND column_name=$2
	LIMIT 1
	"""
	return await conn.fetchval(q, table, column) is not None


async def init_db():
	pool = await get_pool()
	async with pool.acquire() as conn:
		# --- USERS (служебная) ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS users (
			user_id BIGINT PRIMARY KEY,
			state TEXT DEFAULT '',
			flow_status TEXT DEFAULT '',
			last_start_at TEXT DEFAULT '',
			updated_at TEXT DEFAULT ''
		);
		""")

		# --- FLOWS ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS flows (
			name TEXT PRIMARY KEY,
			sort_order INTEGER NOT NULL DEFAULT 0
		);
		""")

		# --- CONTENT BLOCKS ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS content_blocks (
			id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			flow TEXT NOT NULL,
			position INTEGER NOT NULL,
			type TEXT NOT NULL,
			title TEXT DEFAULT '',
			text TEXT DEFAULT '',
			circle_path TEXT DEFAULT '',
			video_url TEXT DEFAULT '',
			buttons_json TEXT DEFAULT '',
			delay_seconds DOUBLE PRECISION DEFAULT 1.0,
			is_active INTEGER DEFAULT 1,

			-- attachments
			file_path TEXT DEFAULT '',
			file_kind TEXT DEFAULT '',
			file_name TEXT DEFAULT ''
		);
		""")

		# --- JOBS ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS jobs (
			id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
			user_id BIGINT NOT NULL,
			flow TEXT NOT NULL,
			run_at_ts BIGINT NOT NULL,
			is_done INTEGER DEFAULT 0
		);
		""")

		# unique for upsert
		await conn.execute("""
		CREATE UNIQUE INDEX IF NOT EXISTS ux_jobs_user_flow
		ON jobs(user_id, flow);
		""")

		# --- BOT USERS (АНАЛИТИКА) ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS bot_users (
			user_id BIGINT PRIMARY KEY,
			username TEXT DEFAULT '',
			first_seen_ts BIGINT NOT NULL,
			last_seen_ts BIGINT NOT NULL,
			starts_count BIGINT NOT NULL DEFAULT 0,
			messages_count BIGINT NOT NULL DEFAULT 0
		);
		""")

		# --- FLOW TRIGGERS ---
		await conn.execute("""
		CREATE TABLE IF NOT EXISTS flow_triggers (
			flow TEXT PRIMARY KEY,
			trigger TEXT NOT NULL DEFAULT 'after_start',
			offset_seconds BIGINT NOT NULL DEFAULT 0,
			is_active INTEGER NOT NULL DEFAULT 1
		);
		""")

		# ---------------- MIGRATIONS (safe add columns) ----------------

		# flows.sort_order
		if not await _column_exists(conn, "flows", "sort_order"):
			await conn.execute("ALTER TABLE flows ADD COLUMN sort_order INTEGER NOT NULL DEFAULT 0;")

		# content_blocks additions
		for col, ddl in [
			("delay_seconds", "ALTER TABLE content_blocks ADD COLUMN delay_seconds DOUBLE PRECISION DEFAULT 1.0;"),
			("title", "ALTER TABLE content_blocks ADD COLUMN title TEXT DEFAULT '';"),
			("file_path", "ALTER TABLE content_blocks ADD COLUMN file_path TEXT DEFAULT '';"),
			("file_kind", "ALTER TABLE content_blocks ADD COLUMN file_kind TEXT DEFAULT '';"),
			("file_name", "ALTER TABLE content_blocks ADD COLUMN file_name TEXT DEFAULT '';"),
		]:
			if not await _column_exists(conn, "content_blocks", col):
				await conn.execute(ddl)

		# restore flows if empty
		cnt = await conn.fetchval("SELECT COUNT(*) FROM flows;")
		if int(cnt or 0) == 0:
			rows = await conn.fetch("SELECT DISTINCT flow FROM content_blocks ORDER BY flow;")
			order = 1
			for r in rows:
				flow = r["flow"]
				await conn.execute(
					"INSERT INTO flows(name, sort_order) VALUES ($1, $2) ON CONFLICT (name) DO NOTHING;",
					flow, order
				)
				order += 1


# ===================== BOT ANALYTICS =====================

async def inc_start(user_id: int, username: Optional[str]):
	now = int(time.time())
	username = (username or "").strip()

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		INSERT INTO bot_users(user_id, username, first_seen_ts, last_seen_ts, starts_count, messages_count)
		VALUES ($1, $2, $3, $4, 1, 0)
		ON CONFLICT (user_id) DO UPDATE SET
			username=EXCLUDED.username,
			last_seen_ts=EXCLUDED.last_seen_ts,
			starts_count=bot_users.starts_count + 1;
		""", int(user_id), username, now, now)


async def inc_message(user_id: int, username: Optional[str]):
	now = int(time.time())
	username = (username or "").strip()

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		INSERT INTO bot_users(user_id, username, first_seen_ts, last_seen_ts, starts_count, messages_count)
		VALUES ($1, $2, $3, $4, 0, 1)
		ON CONFLICT (user_id) DO UPDATE SET
			username=EXCLUDED.username,
			last_seen_ts=EXCLUDED.last_seen_ts,
			messages_count=bot_users.messages_count + 1;
		""", int(user_id), username, now, now)


async def get_stats():
	now = int(time.time())
	hour_ago = now - 3600

	pool = await get_pool()
	async with pool.acquire() as conn:
		total_users = await conn.fetchval("SELECT COUNT(*) FROM bot_users;")
		active_last_hour = await conn.fetchval(
			"SELECT COUNT(*) FROM bot_users WHERE last_seen_ts >= $1;",
			hour_ago
		)
		row = await conn.fetchrow("""
			SELECT COALESCE(SUM(starts_count),0) AS starts,
				   COALESCE(SUM(messages_count),0) AS messages
			FROM bot_users;
		""")

	return {
		"total_users": int(total_users or 0),
		"active_last_hour": int(active_last_hour or 0),
		"total_starts": int(row["starts"] or 0),
		"total_messages": int(row["messages"] or 0),
	}


async def get_users(limit: int = 500):
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("""
		SELECT user_id, username, first_seen_ts, last_seen_ts, starts_count, messages_count
		FROM bot_users
		ORDER BY last_seen_ts DESC
		LIMIT $1;
		""", int(limit))

	return [
		{
			"user_id": int(r["user_id"]),
			"username": r["username"] or "",
			"first_seen_ts": int(r["first_seen_ts"]),
			"last_seen_ts": int(r["last_seen_ts"]),
			"starts_count": int(r["starts_count"]),
			"messages_count": int(r["messages_count"]),
		}
		for r in rows
	]


# ===================== FLOW TRIGGERS (CRM) =====================

async def get_flow_triggers() -> List[Dict]:
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("""
		SELECT flow, trigger, offset_seconds, is_active
		FROM flow_triggers
		ORDER BY offset_seconds ASC, flow ASC;
		""")

	return [
		{
			"flow": r["flow"],
			"trigger": r["trigger"],
			"offset_seconds": int(r["offset_seconds"] or 0),
			"is_active": int(r["is_active"] or 0),
		}
		for r in rows
	]


async def set_flow_trigger(flow: str, offset_seconds: int, is_active: int = 1, trigger: str = "after_start") -> None:
	flow = (flow or "").strip()
	if not flow:
		return

	offset_seconds = int(offset_seconds)
	is_active = 1 if int(is_active) else 0
	trigger = (trigger or "after_start").strip() or "after_start"

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		INSERT INTO flow_triggers(flow, trigger, offset_seconds, is_active)
		VALUES ($1, $2, $3, $4)
		ON CONFLICT (flow) DO UPDATE SET
			trigger=EXCLUDED.trigger,
			offset_seconds=EXCLUDED.offset_seconds,
			is_active=EXCLUDED.is_active;
		""", flow, trigger, offset_seconds, is_active)


async def delete_flow_trigger(flow: str) -> None:
	flow = (flow or "").strip()
	if not flow:
		return

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("DELETE FROM flow_triggers WHERE flow=$1;", flow)


# ===================== JOBS =====================

async def upsert_job(user_id: int, flow: str, run_at_ts: int) -> None:
	flow = (flow or "").strip()
	if not flow:
		return

	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
		INSERT INTO jobs(user_id, flow, run_at_ts, is_done)
		VALUES ($1, $2, $3, 0)
		ON CONFLICT (user_id, flow) DO UPDATE SET
			run_at_ts=EXCLUDED.run_at_ts,
			is_done=0;
		""", int(user_id), flow, int(run_at_ts))


async def fetch_due_jobs(limit: int = 50) -> List[Dict]:
	now = int(time.time())

	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("""
		SELECT id, user_id, flow, run_at_ts
		FROM jobs
		WHERE is_done=0 AND run_at_ts <= $1
		ORDER BY run_at_ts ASC
		LIMIT $2;
		""", now, int(limit))

	return [
		{
			"id": int(r["id"]),
			"user_id": int(r["user_id"]),
			"flow": r["flow"],
			"run_at_ts": int(r["run_at_ts"]),
		}
		for r in rows
	]


async def mark_job_done(job_id: int) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("UPDATE jobs SET is_done=1 WHERE id=$1;", int(job_id))


# ===================== FLOWS =====================

async def get_flows() -> List[str]:
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("SELECT name FROM flows ORDER BY sort_order ASC;")
	return [r["name"] for r in rows]


async def create_flow(name: str) -> None:
	name = (name or "").strip()
	if not name:
		return

	pool = await get_pool()
	async with pool.acquire() as conn:
		mx = await conn.fetchval("SELECT COALESCE(MAX(sort_order), 0) FROM flows;")
		await conn.execute(
			"INSERT INTO flows(name, sort_order) VALUES ($1, $2) ON CONFLICT (name) DO NOTHING;",
			name, int(mx or 0) + 1
		)


async def delete_flow(name: str) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		async with conn.transaction():
			await conn.execute("DELETE FROM content_blocks WHERE flow=$1;", name)
			await conn.execute("DELETE FROM jobs WHERE flow=$1;", name)
			await conn.execute("DELETE FROM flow_triggers WHERE flow=$1;", name)
			await conn.execute("DELETE FROM flows WHERE name=$1;", name)


async def move_flow(name: str, direction: str) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("SELECT name, sort_order FROM flows ORDER BY sort_order ASC;")
		idx = next((i for i, r in enumerate(rows) if r["name"] == name), None)
		if idx is None:
			return

		if direction == "up" and idx > 0:
			a = rows[idx]
			b = rows[idx - 1]
		elif direction == "down" and idx < len(rows) - 1:
			a = rows[idx]
			b = rows[idx + 1]
		else:
			return

		async with conn.transaction():
			await conn.execute("UPDATE flows SET sort_order=$1 WHERE name=$2;", int(b["sort_order"]), a["name"])
			await conn.execute("UPDATE flows SET sort_order=$1 WHERE name=$2;", int(a["sort_order"]), b["name"])


# ===================== CONTENT BLOCKS =====================

async def next_position(flow: str) -> int:
	pool = await get_pool()
	async with pool.acquire() as conn:
		mx = await conn.fetchval("SELECT COALESCE(MAX(position), 0) FROM content_blocks WHERE flow=$1;", flow)
		return int(mx or 0) + 1


async def get_blocks(flow: str) -> List[Dict]:
	pool = await get_pool()
	async with pool.acquire() as conn:
		rows = await conn.fetch("""
			SELECT
				id, flow, position, type,
				title, text,
				circle_path, video_url, buttons_json,
				is_active, delay_seconds,
				file_path, file_kind, file_name
			FROM content_blocks
			WHERE flow=$1
			ORDER BY position ASC;
		""", flow)

	return [
		{
			"id": int(r["id"]),
			"flow": r["flow"],
			"position": int(r["position"]),
			"type": r["type"],
			"title": r["title"] or "",
			"text": r["text"] or "",
			"circle": r["circle_path"] or "",
			"video": r["video_url"] or "",
			"buttons": r["buttons_json"] or "",
			"is_active": int(r["is_active"] or 0),
			"delay": float(r["delay_seconds"] or 1.0),
			"file_path": r["file_path"] or "",
			"file_kind": r["file_kind"] or "",
			"file_name": r["file_name"] or "",
		}
		for r in rows
	]


async def get_block(block_id: int) -> Optional[Dict]:
	pool = await get_pool()
	async with pool.acquire() as conn:
		r = await conn.fetchrow("""
			SELECT
				id, flow, position, type,
				title, text,
				circle_path, video_url, buttons_json,
				is_active, delay_seconds,
				file_path, file_kind, file_name
			FROM content_blocks
			WHERE id=$1;
		""", int(block_id))

	if not r:
		return None

	return {
		"id": int(r["id"]),
		"flow": r["flow"],
		"position": int(r["position"]),
		"type": r["type"],
		"title": r["title"] or "",
		"text": r["text"] or "",
		"circle": r["circle_path"] or "",
		"video": r["video_url"] or "",
		"buttons": r["buttons_json"] or "",
		"is_active": int(r["is_active"] or 0),
		"delay": float(r["delay_seconds"] or 1.0),
		"file_path": r["file_path"] or "",
		"file_kind": r["file_kind"] or "",
		"file_name": r["file_name"] or "",
	}


async def create_block(data: Dict) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
			INSERT INTO content_blocks
			(flow, position, type, title, text, circle_path, video_url, buttons_json,
			 is_active, delay_seconds, file_path, file_kind, file_name)
			VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13);
		""",
			data["flow"], int(data["position"]), data["type"],
			data.get("title", ""), data.get("text", ""),
			data.get("circle", ""), data.get("video", ""),
			data.get("buttons", ""), int(data.get("is_active", 1)),
			float(data.get("delay", 1.0)),
			data.get("file_path", ""),
			data.get("file_kind", ""),
			data.get("file_name", ""),
		)


async def update_block(block_id: int, data: Dict) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("""
			UPDATE content_blocks
			SET flow=$1, position=$2, type=$3,
				title=$4, text=$5, circle_path=$6, video_url=$7, buttons_json=$8,
				is_active=$9, delay_seconds=$10,
				file_path=$11, file_kind=$12, file_name=$13
			WHERE id=$14;
		""",
			data["flow"], int(data["position"]), data["type"],
			data.get("title", ""), data.get("text", ""),
			data.get("circle", ""), data.get("video", ""),
			data.get("buttons", ""), int(data.get("is_active", 1)),
			float(data.get("delay", 1.0)),
			data.get("file_path", ""),
			data.get("file_kind", ""),
			data.get("file_name", ""),
			int(block_id),
		)


async def delete_block(block_id: int) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		await conn.execute("DELETE FROM content_blocks WHERE id=$1;", int(block_id))


async def swap_positions(id_a: int, id_b: int) -> None:
	pool = await get_pool()
	async with pool.acquire() as conn:
		async with conn.transaction():
			a_pos = await conn.fetchval("SELECT position FROM content_blocks WHERE id=$1;", int(id_a))
			b_pos = await conn.fetchval("SELECT position FROM content_blocks WHERE id=$1;", int(id_b))
			if a_pos is None or b_pos is None:
				return
			await conn.execute("UPDATE content_blocks SET position=$1 WHERE id=$2;", int(b_pos), int(id_a))
			await conn.execute("UPDATE content_blocks SET position=$1 WHERE id=$2;", int(a_pos), int(id_b))